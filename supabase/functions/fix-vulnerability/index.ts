import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface FixVulnerabilityRequest {
  repositoryId: string;
  vulnerabilityId: string;
  packageName: string;
  currentVersion: string;
  fixedVersion: string;
  repositoryFullName: string;
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { 
      repositoryId, 
      vulnerabilityId, 
      packageName, 
      currentVersion, 
      fixedVersion,
      repositoryFullName 
    }: FixVulnerabilityRequest = await req.json();

    console.log(`Starting vulnerability fix for ${packageName} in ${repositoryFullName}`);

    // Get GitHub token from secrets
    const githubToken = Deno.env.get('GITHUB_TOKEN');
    if (!githubToken) {
      throw new Error('GitHub token not configured. Please add GITHUB_TOKEN to your Supabase secrets.');
    }

    const [owner, repo] = repositoryFullName.split('/');
    const githubApiBase = `https://api.github.com/repos/${owner}/${repo}`;

    // Create a new branch for the vulnerability fix
    const branchName = `fix/${vulnerabilityId.toLowerCase()}-${packageName.replace(/[^a-zA-Z0-9]/g, '-')}`;
    
    // Get the default branch SHA
    const repoResponse = await fetch(`${githubApiBase}`, {
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json',
      },
    });

    if (!repoResponse.ok) {
      throw new Error(`Failed to fetch repository info: ${repoResponse.statusText}`);
    }

    const repoData = await repoResponse.json();
    const defaultBranch = repoData.default_branch;

    // Get the SHA of the default branch
    const refResponse = await fetch(`${githubApiBase}/git/ref/heads/${defaultBranch}`, {
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json',
      },
    });

    if (!refResponse.ok) {
      throw new Error(`Failed to get branch reference: ${refResponse.statusText}`);
    }

    const refData = await refResponse.json();
    const baseSha = refData.object.sha;

    // Create new branch
    const createBranchResponse = await fetch(`${githubApiBase}/git/refs`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        ref: `refs/heads/${branchName}`,
        sha: baseSha,
      }),
    });

    if (!createBranchResponse.ok) {
      const errorText = await createBranchResponse.text();
      console.error('Create branch error:', errorText);
      
      // Parse error response for better error messages
      let errorMessage = `Failed to create branch: ${createBranchResponse.statusText}`;
      try {
        const errorData = JSON.parse(errorText);
        if (errorData.message === "Resource not accessible by personal access token") {
          errorMessage = `Cannot create branch in ${repositoryFullName}. This repository requires write access. Make sure you own this repository or have been granted write permissions by the repository owner.`;
        } else if (errorData.message?.includes("Not Found")) {
          errorMessage = `Repository ${repositoryFullName} not found or not accessible with your GitHub token.`;
        } else {
          errorMessage = `GitHub API Error: ${errorData.message}`;
        }
      } catch (parseError) {
        // Keep original error if parsing fails
      }
      
      throw new Error(errorMessage);
    }

    // Now update the package files based on the language/framework
    const filesToUpdate = await getFilesToUpdate(githubApiBase, githubToken, packageName, currentVersion, fixedVersion);
    
    for (const fileUpdate of filesToUpdate) {
      await updateFile(githubApiBase, githubToken, branchName, fileUpdate);
    }

    // Create pull request
    const prTitle = `Security fix: Update ${packageName} to ${fixedVersion}`;
    const prBody = `
## Security Vulnerability Fix

**Vulnerability ID:** ${vulnerabilityId}
**Package:** ${packageName}
**Current Version:** ${currentVersion}
**Fixed Version:** ${fixedVersion}

This PR updates the ${packageName} dependency to version ${fixedVersion} to address a security vulnerability.

### Changes Made:
${filesToUpdate.map(file => `- Updated ${file.path}`).join('\n')}

### Security Impact:
Updating to version ${fixedVersion} resolves the security vulnerability and ensures the application is protected against potential threats.

**Please review and merge this PR to apply the security fix.**
    `;

    const createPrResponse = await fetch(`${githubApiBase}/pulls`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${githubToken}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title: prTitle,
        head: branchName,
        base: defaultBranch,
        body: prBody,
      }),
    });

    if (!createPrResponse.ok) {
      const errorText = await createPrResponse.text();
      console.error('Create PR error:', errorText);
      throw new Error(`Failed to create pull request: ${createPrResponse.statusText}`);
    }

    const prData = await createPrResponse.json();

    console.log(`Vulnerability fix PR created successfully: ${prData.html_url}`);

    return new Response(
      JSON.stringify({
        success: true,
        pullRequestNumber: prData.number,
        pullRequestUrl: prData.html_url,
        branchName,
        message: `Security fix PR created for ${packageName} vulnerability`
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      },
    );

  } catch (error) {
    console.error('Vulnerability fix error:', error);
    
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message || 'Failed to create vulnerability fix'
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      },
    );
  }
});

async function getFilesToUpdate(githubApiBase: string, token: string, packageName: string, currentVersion: string, fixedVersion: string) {
  const filesToUpdate = [];

  // Check for package.json (Node.js/TypeScript projects)
  try {
    const packageJsonResponse = await fetch(`${githubApiBase}/contents/package.json`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
      },
    });

    if (packageJsonResponse.ok) {
      const packageJsonData = await packageJsonResponse.json();
      const content = atob(packageJsonData.content);
      const packageJson = JSON.parse(content);
      
      // Update dependencies
      let updated = false;
      if (packageJson.dependencies && packageJson.dependencies[packageName]) {
        packageJson.dependencies[packageName] = `^${fixedVersion}`;
        updated = true;
      }
      if (packageJson.devDependencies && packageJson.devDependencies[packageName]) {
        packageJson.devDependencies[packageName] = `^${fixedVersion}`;
        updated = true;
      }

      if (updated) {
        filesToUpdate.push({
          path: 'package.json',
          content: JSON.stringify(packageJson, null, 2),
          sha: packageJsonData.sha
        });
      }
    }
  } catch (error) {
    console.log('No package.json found or error reading it');
  }

  // Check for pom.xml (Java/Maven projects)
  try {
    const pomResponse = await fetch(`${githubApiBase}/contents/pom.xml`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
      },
    });

    if (pomResponse.ok) {
      const pomData = await pomResponse.json();
      const content = atob(pomData.content);
      
      // Update Maven dependencies
      const updatedContent = updateMavenDependency(content, packageName, fixedVersion);
      if (updatedContent !== content) {
        filesToUpdate.push({
          path: 'pom.xml',
          content: updatedContent,
          sha: pomData.sha
        });
      }
    }
  } catch (error) {
    console.log('No pom.xml found or error reading it');
  }

  // Check for build.gradle (Java/Gradle projects)
  try {
    const gradleResponse = await fetch(`${githubApiBase}/contents/build.gradle`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
      },
    });

    if (gradleResponse.ok) {
      const gradleData = await gradleResponse.json();
      const content = atob(gradleData.content);
      
      // Update Gradle dependencies
      const updatedContent = updateGradleDependency(content, packageName, fixedVersion);
      if (updatedContent !== content) {
        filesToUpdate.push({
          path: 'build.gradle',
          content: updatedContent,
          sha: gradleData.sha
        });
      }
    }
  } catch (error) {
    console.log('No build.gradle found or error reading it');
  }

  return filesToUpdate;
}

async function updateFile(githubApiBase: string, token: string, branchName: string, fileUpdate: any) {
  const updateResponse = await fetch(`${githubApiBase}/contents/${fileUpdate.path}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      message: `Security fix: Update ${fileUpdate.path}`,
      content: btoa(fileUpdate.content),
      sha: fileUpdate.sha,
      branch: branchName,
    }),
  });

  if (!updateResponse.ok) {
    const errorText = await updateResponse.text();
    throw new Error(`Failed to update ${fileUpdate.path}: ${errorText}`);
  }
}

function updateMavenDependency(content: string, packageName: string, version: string): string {
  // Simple regex replacement for Maven dependencies
  const groupId = packageName.split('.').slice(0, -1).join('.');
  const artifactId = packageName.split('.').pop();
  
  const dependencyRegex = new RegExp(
    `(<dependency>\\s*<groupId>${groupId}</groupId>\\s*<artifactId>${artifactId}</artifactId>\\s*<version>)[^<]+(</version>)`,
    'g'
  );
  
  return content.replace(dependencyRegex, `$1${version}$2`);
}

function updateGradleDependency(content: string, packageName: string, version: string): string {
  // Simple regex replacement for Gradle dependencies
  const dependencyRegex = new RegExp(
    `(['"]${packageName}:)[^'"]+(['"])`,
    'g'
  );
  
  return content.replace(dependencyRegex, `$1${version}$2`);
}